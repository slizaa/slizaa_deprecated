/*
 * generated by Xtext 2.10.0
 */
package org.slizaa.neo4j.hierarchicalgraph.mapping.dsl.validation

import org.eclipse.core.runtime.Platform
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.slizaa.neo4j.hierarchicalgraph.mapping.dsl.mappingDsl.MappingDslPackage
import org.slizaa.neo4j.hierarchicalgraph.mapping.dsl.mappingDsl.StructureDescriptor
import org.slizaa.neo4j.hierarchicalgraph.mapping.dsl.mappingDsl.TopLevelNodesQueries
import org.slizaa.neo4j.opencypher.openCypher.Cypher
import org.slizaa.neo4j.opencypher.openCypher.Return
import org.slizaa.neo4j.opencypher.util.CypherNormalizer
import org.eclipse.emf.ecore.EObject

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MappingDslValidator extends AbstractMappingDslValidator {

	public static val MISSING_TOP_LEVEL_NODE_QUERIES = 'missingTopLevelNodeQueries'

	public static val INVALID_TOP_LEVEL_NODES_QUERY_COUNT = 'invalidTopLevelNodeQueryCount'

	public static val INVALID_CYPHER_QUERY = 'invalidCypherQuery'

	@Check
	def missingTopLevelNodesQueries(StructureDescriptor structureDescriptor) {
		if (structureDescriptor.topLevelNodeQueries == null) {
			error('Missing top level node queries.',
				MappingDslPackage.Literals.STRUCTURE_DESCRIPTOR__TOP_LEVEL_NODE_QUERIES, MISSING_TOP_LEVEL_NODE_QUERIES)
		}
	}

	@Check
	def checkAtLeastOneTopLevelNodesQuery(TopLevelNodesQueries topLevelNodesQueries) {
		if (topLevelNodesQueries.queries.nullOrEmpty) {
			error('At least one top level node query has to be specified.',
				MappingDslPackage.Literals.TOP_LEVEL_NODES_QUERIES__QUERIES, INVALID_TOP_LEVEL_NODES_QUERY_COUNT)
		}
	}

	@Check
	def checkTopLevelNodesQueries(TopLevelNodesQueries topLevelNodesQueries) {
		println("checkTopLevelNodesQueries")
		for (String query : topLevelNodesQueries.queries) {

// TODO : Adapter usage with platform NOT running?
			if (Platform.isRunning) {
				val c = Platform.getAdapterManager().loadAdapter(CypherNormalizer.normalize(query), Cypher.name)
				if (c == null) {
					error('Invalid cypher query.', MappingDslPackage.Literals.TOP_LEVEL_NODES_QUERIES__QUERIES,
						topLevelNodesQueries.queries.indexOf(query), INVALID_CYPHER_QUERY)
				} else {
					val Return ret = EcoreUtil2.eAllOfType(c as EObject, Return).stream.findFirst.orElse(null);
					if (ret == null) {
						error('Invalid cypher query.', MappingDslPackage.Literals.TOP_LEVEL_NODES_QUERIES__QUERIES,
							topLevelNodesQueries.queries.indexOf(query), INVALID_CYPHER_QUERY)
					} else {
						println(ret)
					}
				}
			}
		}
	}
}
